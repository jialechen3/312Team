<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Battlefield</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: url('/static/images/tag_battle_bg.png') no-repeat center -530px fixed;
      background-size: cover;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: crosshair;
    }

    canvas {
      background: #1e1e2f;
      border-radius: 12px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
      z-index: 10;
      position: relative;
    }
  </style>
</head>
<body>
<canvas id="game" width="1000" height="800"></canvas>

<script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const socket = io();

  const urlParams = new URLSearchParams(window.location.search);
  const roomId = urlParams.get('room');
  if (!roomId) {
    alert("Room ID is missing in the URL.");
    throw new Error("Room ID not found");
  }

  const TILE_SIZE = 40;
  const MAP_WIDTH = 100;
  const MAP_HEIGHT = 100;

  const terrain = Array.from({ length: MAP_HEIGHT }, (_, y) =>
    Array.from({ length: MAP_WIDTH }, (_, x) => {
      if (y < 5 && x >= MAP_WIDTH - 5) {
        const insideX = x >= MAP_WIDTH - 4 && x <= MAP_WIDTH - 2;
        const insideY = y >= 1 && y <= 3;
        if (insideX && insideY) return 0;
        return 3;
      }
      if (y >= MAP_HEIGHT - 5 && x < 5) return 2;
      if ((x + y) % 17 === 0 && x > 5 && x < MAP_WIDTH - 6 && y > 5 && y < MAP_HEIGHT - 6) return 1;
      return 0;
    })
  );

  let playerId = null;
  let players = {};
  let pos = { x: 0, y: 0 };
  let deadPlayers = {};    // Track if player is dead
  let respawnTimers = {};  // Track remaining respawn time per player

  fetch('/api/whoami', { credentials: 'include' })
    .then(res => res.json())
    .then(data => {
      if (data.username) {
        playerId = data.username;
        joinGame();
      } else {
        alert("Not authenticated");
        window.location.href = "/login";
      }
    });

  function joinGame() {
    socket.emit('join_room', { room_id: roomId, player: playerId });

    socket.on('player_positions', (playerList) => {
      console.log("Received player_positions:", playerList);
      players = {};
      playerList.forEach(p => {
        players[p.id] = { x: p.x, y: p.y };
      });

      if (players[playerId]) {
        pos = { ...players[playerId] };
        console.log("Camera centered on", pos);
      }

      draw();
    });

    socket.on('player_tagged', ({ tagger, target }) => {
      console.log(`[TAG] ${tagger} tagged ${target}`);
      deadPlayers[target] = true;
      respawnTimers[target] = 10; // Start at 10 seconds

      const timer = setInterval(() => {
        respawnTimers[target]--;
        if (respawnTimers[target] <= 0) {
          clearInterval(timer);
        }
      }, 1000);
    });

    socket.on('player_respawned', ({ player }) => {
      console.log(`[RESPAWN] ${player} is now alive`);
      deadPlayers[player] = false;
      delete respawnTimers[player];
    });

    document.addEventListener('keydown', handleMovement);
    setInterval(draw, 1000 / 60); // Redraw 60fps
  }

  function handleMovement(e) {
    if (e.key === "ArrowUp") pos.y--;
    if (e.key === "ArrowDown") pos.y++;
    if (e.key === "ArrowLeft") pos.x--;
    if (e.key === "ArrowRight") pos.x++;

    pos.x = Math.max(0, Math.min(pos.x, MAP_WIDTH - 1));
    pos.y = Math.max(0, Math.min(pos.y, MAP_HEIGHT - 1));

    socket.emit('move', {
      roomId: roomId,
      player: playerId,
      x: pos.x,
      y: pos.y
    });
  }

  function drawGrid(viewX, viewY) {
    const cols = Math.ceil(canvas.width / TILE_SIZE);
    const rows = Math.ceil(canvas.height / TILE_SIZE);

    for (let x = 0; x < cols; x++) {
      for (let y = 0; y < rows; y++) {
        const worldX = Math.floor(viewX + x);
        const worldY = Math.floor(viewY + y);

        if (worldX < MAP_WIDTH && worldY < MAP_HEIGHT) {
          const tileType = terrain[worldY][worldX];
          switch (tileType) {
            case 1: ctx.fillStyle = 'gray'; break;
            case 2: ctx.fillStyle = 'blue'; break;
            case 3: ctx.fillStyle = 'red'; break;
            default: ctx.fillStyle = '#1e1e2f';
          }
          ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
          ctx.strokeStyle = '#222';
          ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }
  }

  function drawPlayers(viewX, viewY) {
    ctx.font = "12px Arial";

    Object.keys(players).forEach((id) => {
      const { x, y } = players[id];
      const screenX = (x - viewX) * TILE_SIZE;
      const screenY = (y - viewY) * TILE_SIZE;

      if (deadPlayers[id]) {
        ctx.fillStyle = 'gray'; // Dead players = gray box
      } else {
        ctx.fillStyle = id === playerId ? 'lime' : 'red'; // Alive: green or red
      }

      ctx.fillRect(screenX, screenY, TILE_SIZE, TILE_SIZE);

      ctx.fillStyle = 'white';
      ctx.fillText(id, screenX + 5, screenY + 15);

      if (deadPlayers[id]) {
        ctx.fillStyle = 'yellow';
        if (respawnTimers[id] !== undefined) {
          ctx.fillText(`Respawn: ${respawnTimers[id]}`, screenX + 5, screenY + 30);
        } else {
          ctx.fillText("DEAD", screenX + 5, screenY + 30);
        }
      }
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const tilesInViewX = canvas.width / TILE_SIZE;
    const tilesInViewY = canvas.height / TILE_SIZE;

    let viewX = pos.x - Math.floor(tilesInViewX / 2);
    let viewY = pos.y - Math.floor(tilesInViewY / 2);

    viewX = Math.max(0, Math.min(viewX, MAP_WIDTH - tilesInViewX));
    viewY = Math.max(0, Math.min(viewY, MAP_HEIGHT - tilesInViewY));

    drawGrid(viewX, viewY);
    drawPlayers(viewX, viewY);
  }
</script>
</body>
</html>

